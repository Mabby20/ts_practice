//! если функция не возвращает вообще ничего - то тип будет void
const fn1 = () => { } // void

//! как только функция возвращает хоть что-то, возвращаемой значение будет возвр. значение и undefined
const fn2 = (arg1: string, arg2?: string) => { // string | undefined
    if (arg2) {
        return arg1;
    }
}

//_________________________________

//! Такое определие типа, с возвращаемым значением void, в основном говорит о том что функция игнорирует возвращаемое значение.
//! т.е. можно вернуть любое значение и не будет ругаться на такой тип.
//! сделано это для того что бы можно было типизировать функции в которых важен факт выолнения операции, а не возвращаемое значение.
//! как пример, это функция логирования, возвращает undefined, или например forEach - ничего не возращает, и может вернуть что-то, но это значение будет не важно.
type FnDef = () => void

const fn3: FnDef = () => { }; //* тип void соответствует определению функциию FnDef

const fn4: FnDef = () => true; //* вернули boolean, но TS не ругается на несоответсвие типу. Т.е. опредление фунции проигнорировало возвращаемое значение.

const arr = ['1', '2', '3'];

const res: string[] = []

//* возвращает res.push(el) длину массива, но forEach - возвращает void, т.е ему абсолютно не важно что будет возвращаться, важна сама операция.
//* В другом случае типизация в forEach не работало бы
arr.forEach((el) => res.push(el))

